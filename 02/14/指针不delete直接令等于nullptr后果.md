在C++中，如果你创建了一个动态分配的对象（使用new关键字）而没有在不再需要它时使用delete来释放它，那么你就会遇到内存泄漏（memory leak）的问题。内存泄漏意味着程序在运行时不断地消耗更多的内存，但这些内存在程序结束时并不会被释放，这可能会导致系统资源耗尽。

将指针设置为nullptr（或者NULL，在C++11之前的版本中）不会释放该指针所指向的内存。它只会使得指针本身不再指向那块内存，那块内存仍然被占用，并且没有任何指针指向它。这就造成了所谓的“悬挂指针”（dangling pointer）或者“野指针”（wild pointer），它指向的内存区域是不安全的，访问它可能会导致程序崩溃或其他未定义行为。

下面是一个简单的示例，展示了不进行delete操作直接设置nullptr可能导致的问题：

```cpp
#include <iostream>

int main() {
    int* ptr = new int(5);  // 动态分配一个整数并初始化为5
    std::cout << *ptr << std::endl;  // 输出5

    ptr = nullptr;  // 将ptr设置为nullptr，但之前的内存没有被释放

    // 下面的代码将尝试访问已经被释放（但实际上没有被释放）的内存
    // 这可能导致程序崩溃或其他未定义行为
    std::cout << *ptr << std::endl;  // 未定义行为

    return 0;
}
```
在这个示例中，即使我们将ptr设置为nullptr，之前通过new分配的内存仍然没有被释放。如果你运行这段代码，它可能会崩溃，或者输出一些不可预测的值，因为*ptr现在指向了一个随机的内存位置。

为了避免这种问题，你应该总是在不再需要动态分配的对象时使用delete（或delete[]，对于数组）来释放内存。例如：

```cpp
delete ptr;  // 释放ptr所指向的内存
ptr = nullptr;  // 现在将ptr设置为nullptr是安全的
```
这样可以确保内存被正确释放，从而避免内存泄漏和悬挂指针的问题。